

export class Microphone {
    constructor(audioContext, processFrame, processError, onStart = (stream) => { }) {
        this.onStart = onStart
        this.audioContext = audioContext;
        this.processFrame = processFrame;
        this.frequencyBuffer = new Float32Array(2048)
        this.connectStream = this.connectStream.bind(this);
        navigator.mediaDevices.getUserMedia({ audio: true, video: false })
            .then(this.connectStream)
            .catch((error) => {
                if (processError) {
                    processError(error);
                }
            });
        this.raf = 0
    }

    /**
     * 
     * @param {MediaStream} stream 
     */
    connectStream(stream) {
        this.onStart(stream)
        this.stream = stream
        this.analyser = this.audioContext.createAnalyser();
        const source = this.audioContext.createMediaStreamSource(stream);
        source.connect(this.analyser);
        this.analyser.smoothingTimeConstant = 0.5;
        this.analyser.fftSize = 2048;

        this.initRenderLoop(this.analyser);
    }

    autoCorrelate(buf, sampleRate) {
        const size = buf.length;
        const max_samples = Math.floor(size / 2)
        let best_offset = -1;
        let best_correlation = 0;
        let rms = 0;
        let foundGoodCorrelation = false;
        const correlations = new Array(max_samples);

        for (let i = 0; i < size; i++) {
            const val = buf[i];
            rms += val * val;
        }
        rms = Math.sqrt(rms / size);
        if (rms < 0.01) // not enough signal
            return -1;
        let lastCorrelation = 1;
        for (let offset = 0; offset < max_samples; offset++) {
            let correlation = 0;

            for (let i = 0; i < max_samples; i++) {
                correlation += Math.abs((buf[i]) - (buf[i + offset]));
            }
            correlation = 1 - (correlation / max_samples);
            correlations[offset] = correlation; // store it, for the tweaking we need to do below.
            if ((correlation > 0.9) && (correlation > lastCorrelation)) {
                foundGoodCorrelation = true;
                if (correlation > best_correlation) {
                    best_correlation = correlation;
                    best_offset = offset;
                }
            } else if (foundGoodCorrelation) {
                const shift = (correlations[best_offset + 1] - correlations[best_offset - 1]) / correlations[best_offset];
                return sampleRate / (best_offset + (8 * shift));
            }
            lastCorrelation = correlation;
        }
        if (best_correlation > 0.01) {
            return sampleRate / best_offset;
        }
        return -1;
    }

    initRenderLoop() {
        const processFrame = this.processFrame || (() => { });
        const renderFrame = () => {
            this.analyser.getFloatTimeDomainData(this.frequencyBuffer)
            const pitch = this.autoCorrelate(this.frequencyBuffer, this.audioContext.sampleRate)
            processFrame(pitch);
            this.raf = requestAnimationFrame(renderFrame);
        };
        this.raf = requestAnimationFrame(renderFrame);
    }

    stop() {
        this.stream.getTracks().forEach(o => o.stop())
        cancelAnimationFrame(this.raf)
    }
} 